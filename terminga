#!/usr/bin/env python3


import curses
import re

from curses.textpad import Textbox
from datetime import datetime, timedelta
from operator import itemgetter
from os.path import expanduser

from icinga import Icinga


VERSION = 'v1'
HELP = f'terminga {VERSION} | ' + \
        'q: Quit | r: Refresh | b: Only broken | f: Filter | ' + \
        'c: Clear sel | s: View sel | d: Downtime'


def addstr(win, *args, **kwargs):
    try:
        win.addstr(*args, **kwargs)
    except curses.error:
        pass


def line(msg, width):
    return msg[:width] + ' ' * (width - len(msg))


def title(win, msg):
    height, width = win.getmaxyx()
    addstr(win, 0, 0, line(msg, width), curses.color_pair(1))


def status(win, msg):
    height, width = win.getmaxyx()
    addstr(win, height - 1, 0, line(msg, width), curses.color_pair(1))


def color_for_state(state):
    return curses.color_pair(state + 2)


def filter_items(icinga_items, only_broken, filters):
    hosts = icinga_items['hosts']
    services = icinga_items['services']

    hosts_downtime = set()
    buffered = []

    for host in hosts:
        if host.downtime_depth > 0:
            hosts_downtime.add(host.host_name)
        if only_broken:
            if host.host_name in hosts_downtime:
                continue
            if host.state == 0 or host.state_type == 0:
                continue

        buffered.append(host)

    for service in services:
        if only_broken:
            if service.downtime_depth > 0:
                continue
            if service.host_name in hosts_downtime:
                continue
            if service.state == 0 or service.state_type == 0:
                continue

        buffered.append(service)

    mut_filters = filters[:]
    while mut_filters:
        f = mut_filters.pop(0)
        match_re_comp = re.compile(f, re.I)

        new_buffered = []
        for item in buffered:
            if match_re_comp.search(item.get_line_to_show(0)):
                new_buffered.append(item)
        buffered = new_buffered

    return buffered


def list_items(win, offset, current, icinga_items, selected):
    height, width = win.getmaxyx()
    bottompad = starty = at_y = 1

    output_lines = []
    output_extra = 0
    if 0 <= current < len(icinga_items):
        output_lines = icinga_items[current].output_lines
        output_extra = 1

    max_host_len = 0
    for i in icinga_items:
        max_host_len = max(max_host_len, len(i.host_name))

    for i, item in enumerate(icinga_items):
        if at_y >= height - 1 - len(output_lines) - output_extra:
            break

        if i - offset < 0 or i - offset >= (height - bottompad) - starty:
            continue

        attrs = color_for_state(item.state)
        if i == current:
            attrs |= curses.A_REVERSE

        if item in selected:
            attrs |= curses.A_BOLD

        addstr(win, at_y, 0, line(item.get_line_to_show(max_host_len), width), attrs)

        at_y += 1

    at_y = height - 1 - len(output_lines) - output_extra
    if at_y > 1:
        if len(output_lines) > 0:
            addstr(win, at_y, 0, line('', width), curses.color_pair(1))
            at_y += 1
        for output in output_lines:
            addstr(win, at_y, 0, line(output, width), curses.color_pair(0))
            at_y += 1

    return len(output_lines) + output_extra


def query_new_filter(win, existing):
    new = query_string(win, 'Add filter: ')
    if not new:
        return existing

    return existing + [new]


def query_string(win, prompt):
    height, width = win.getmaxyx()
    addstr(win, height - 1, 0, prompt, curses.color_pair(1))
    curses.curs_set(True)
    win.refresh()

    editwin = curses.newwin(1, width - len(prompt), height - 1, len(prompt))
    box = Textbox(editwin)
    box.edit()
    out = box.gather()

    curses.curs_set(False)
    del editwin
    win.touchwin()
    win.refresh()

    return out.strip()


def interact(win, icinga):
    curses.curs_set(False)

    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_YELLOW, curses.COLOR_BLUE)
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    curses.init_pair(3, curses.COLOR_YELLOW, -1)
    curses.init_pair(4, curses.COLOR_RED, -1)
    curses.init_pair(5, curses.COLOR_MAGENTA, -1)

    filters = []

    filter_dirty = True
    force_refresh = False
    icinga_items = None
    only_broken = True
    scroll_dirty = True
    selected = set()
    only_selected = False

    current = 0
    offset = 0

    title(win, HELP)
    status(win, '')

    while True:
        height, width = win.getmaxyx()

        if icinga_items is None or force_refresh:
            status(win, 'Refreshing ...')
            win.refresh()

            selected = set()
            icinga_items = icinga.get_current_state()
            last_key = datetime.now()
            filter_dirty = True
            scroll_dirty = True
            force_refresh = False

        if filter_dirty:
            if only_selected:
                to_display = sorted(selected)
            else:
                to_display = sorted(filter_items(icinga_items, only_broken, filters))
            scroll_dirty = True
            filter_dirty = False

        if scroll_dirty:
            current = 0
            offset = 0
            scroll_dirty = False

        win.erase()
        title(win, HELP)
        status(win, f'Filter: {" > ".join(filters) if filters else "<none>"}')

        border_pane = list_items(win, offset, current, to_display, selected)
        height -= border_pane

        win.refresh()
        win.timeout(1000)
        char = win.getch()
        win.timeout(-1)

        if char in [ord('q')]:
            return
        if char in [ord('b')]:
            only_broken = not only_broken
            filter_dirty = True
        if char in [ord('d')]:
            duration = query_string(win, 'Duration [2h]: ')
            comment = query_string(win, 'Comment [go away]: ')
            status(win, 'Setting downtime ...')
            win.refresh()
            icinga.set_downtime(selected if selected else to_display, comment, duration)
            force_refresh = True
        if char in [ord('r')]:
            force_refresh = True
        if char in [ord('f')]:
            filters = query_new_filter(win, filters)
            filter_dirty = True
        if char in [ord('F')]:
            if filters:
                filters.pop()
                filter_dirty = True

        # Selections.
        if char in [ord(' ')]:
            try:
                selected.remove(to_display[current])
            except KeyError:
                selected.add(to_display[current])
            current += 1

        if char in [ord('c')]:
            selected = set()
        if char in [ord('s')]:
            only_selected = not only_selected
            filter_dirty = True

        # Scrolling.
        bottompad = starty = 1

        if char in [ord('j')]: current += 1
        if char in [ord('k')]: current -= 1

        if char in [ord('g')]: current = 0
        if char in [ord('G')]: current = len(to_display) - 1

        if char in [6]: current += int(0.5 * (height - starty))  # ^F
        if char in [2]: current -= int(0.5 * (height - starty))  # ^B

        if current < 0:
            current = 0
        if current >= len(to_display):
            current = len(to_display) - 1

        # Scroll up or down if needed.
        if current - offset >= (height - bottompad) - starty:
            offset = current - (height - bottompad) + starty + 1
        if current - offset <= -1:
            offset = current

        if offset < 0:
            offset = 0
        if offset >= len(to_display):
            offset = len(to_display) - 1

        if char != -1:
            last_key = datetime.now()
        else:
            if datetime.now() - last_key > timedelta(seconds=30):
                force_refresh = True
                last_key = datetime.now()


if __name__ == '__main__':
    with open(expanduser('~/.terminga'), 'r') as fp:
        lines = fp.read().splitlines()

    icinga = Icinga()
    icinga.settings = {
        'auth': (lines[1], lines[2]),
        'base_url': lines[0],
    }

    curses.wrapper(interact, icinga)
