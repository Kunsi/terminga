#!/usr/bin/env python3


import curses
import re

from curses.textpad import Textbox
from datetime import datetime, timedelta
from operator import itemgetter
from os.path import expanduser

from icinga import Icinga


VERSION = '1'


def addstr(win, *args, **kwargs):
    try:
        win.addstr(*args, **kwargs)
    except curses.error:
        pass


def line(msg, width):
    return msg + ' ' * (width - len(msg))


def title(win, msg):
    height, width = win.getmaxyx()
    addstr(win, 0, 0, line(msg, width), curses.color_pair(1))


def status(win, msg):
    height, width = win.getmaxyx()
    addstr(win, height - 1, 0, line(msg, width), curses.color_pair(1))


def color_for_state(state):
    return curses.color_pair(state + 2)


def filter_items(icinga_items, only_broken, match_re):
    hosts = icinga_items['hosts']
    services = icinga_items['services']

    hosts_downtime = set()
    buffered = []

    for host in hosts:
        if host.downtime_depth > 0:
            hosts_downtime.add(host.host_name)
        if only_broken:
            if host.host_name in hosts_downtime:
                continue
            if host.state == 0:
                continue

        buffered.append(host)

    for service in services:
        if only_broken:
            if service.downtime_depth > 0:
                continue
            if service.host_name in hosts_downtime:
                continue
            if service.state == 0:
                continue

        buffered.append(service)

    buffered = sorted(buffered)

    match_re_comp = re.compile(match_re, re.I)
    for item in buffered:
        if match_re_comp.search(item.get_line_to_show(0)):
            yield item


def list_items(win, offset, current, icinga_items, selected):
    height, width = win.getmaxyx()
    bottompad = starty = at_y = 1

    max_host_len = 0
    for i in icinga_items:
        max_host_len = max(max_host_len, len(i.host_name))

    for i, item in enumerate(icinga_items):
        if at_y >= height - 1:
            return

        if i - offset < 0 or i - offset >= (height - bottompad) - starty:
            continue

        attrs = color_for_state(item.state)
        if i == current:
            attrs |= curses.A_REVERSE

        if item in selected:
            attrs |= curses.A_BOLD

        addstr(win, at_y, 0, line(item.get_line_to_show(max_host_len), width), attrs)

        at_y += 1


def query_string(win, prompt):
    height, width = win.getmaxyx()
    addstr(win, 0, 0, prompt, curses.color_pair(1))
    curses.curs_set(True)
    win.refresh()

    editwin = curses.newwin(1, width - len(prompt), 0, len(prompt))
    box = Textbox(editwin)
    box.edit()
    out = box.gather()

    curses.curs_set(False)
    del editwin
    win.touchwin()
    win.refresh()

    return out.strip()


def interact(win, icinga):
    curses.curs_set(False)

    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_YELLOW, curses.COLOR_BLUE)
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    curses.init_pair(3, curses.COLOR_YELLOW, -1)
    curses.init_pair(4, curses.COLOR_RED, -1)
    curses.init_pair(5, curses.COLOR_MAGENTA, -1)

    filter_dirty = True
    force_refresh = False
    icinga_items = None
    match_re = '.*'
    only_broken = True
    scroll_dirty = True
    selected = set()

    current = 0
    offset = 0

    while True:
        height, width = win.getmaxyx()

        if icinga_items is None or force_refresh:
            status(win, 'Refreshing ...')
            win.refresh()

            selected = set()
            icinga_items = icinga.get_current_state()
            last_key = datetime.now()
            scroll_dirty = True
            force_refresh = False

        if filter_dirty:
            to_display = list(filter_items(icinga_items, only_broken, match_re))
            scroll_dirty = True
            filter_dirty = False

        if scroll_dirty:
            current = 0
            offset = 0
            scroll_dirty = False

        win.erase()
        title(win, f'Filter: {match_re}')
        status(win, f'terminga v{VERSION} | q: Quit | r: Refresh | b: Only broken | '
                     'd: Downtime | /: Search')

        list_items(win, offset, current, to_display, selected)

        win.refresh()
        win.timeout(1000)
        char = win.getch()
        win.timeout(-1)

        if char in [ord('q')]:
            return
        if char in [ord('b')]:
            only_broken = not only_broken
            filter_dirty = True
        if char in [ord('d')]:
            duration = query_string(win, 'Duration [2h]: ')
            comment = query_string(win, 'Comment [go away]: ')
            icinga.set_downtime(selected, comment, duration)
            force_refresh = True
        if char in [ord('r')]:
            force_refresh = True
            filter_dirty = True
        if char in [ord('/')]:
            match_re = query_string(win, '/')
            filter_dirty = True

        # Selections.
        if char in [ord(' ')]:
            try:
                selected.remove(to_display[current])
            except KeyError:
                selected.add(to_display[current])
            current += 1

        # Scrolling.
        bottompad = starty = 1

        if char in [ord('j')]: current += 1
        if char in [ord('k')]: current -= 1

        if char in [ord('g')]: current = 0
        if char in [ord('G')]: current = len(to_display) - 1

        if char in [6]: current += int(0.5 * (height - starty))  # ^F
        if char in [2]: current -= int(0.5 * (height - starty))  # ^B

        if current < 0:
            current = 0
        if current >= len(to_display):
            current = len(to_display) - 1

        # Scroll up or down if needed.
        if current - offset >= (height - bottompad) - starty:
            offset = current - (height - bottompad) + starty + 1
        if current - offset <= -1:
            offset = current

        if offset < 0:
            offset = 0
        if offset >= len(to_display):
            offset = len(to_display) - 1

        if char != -1:
            last_key = datetime.now()
        else:
            if datetime.now() - last_key > timedelta(seconds=30):
                force_refresh = True
                last_key = datetime.now()


if __name__ == '__main__':
    with open(expanduser('~/.terminga'), 'r') as fp:
        lines = fp.read().splitlines()

    icinga = Icinga()
    icinga.settings = {
        'auth': (lines[1], lines[2]),
        'base_url': lines[0],
    }

    curses.wrapper(interact, icinga)
