#!/usr/bin/env python3


import curses
import re

from curses.textpad import Textbox
from datetime import datetime, timedelta
from operator import itemgetter
from os.path import expanduser
from shlex import split
from signal import signal, SIGCHLD, SIG_IGN
from subprocess import Popen
from time import sleep

from icinga import Icinga


VERSION = 'v2'
HELP = f'terminga {VERSION} | q: Quit | ?: Help'

COLORS = {
    'default': 0,
    'bar': 1,
    'state_ok': 2,
    'state_warning': 3,
    'state_critical': 4,
    'state_unknown': 5,
}
STATES = {
    0: 'ok',
    1: 'warning',
    2: 'critical',
    3: 'unknown',
    'ok': 0,
    'warning': 1,
    'critical': 2,
    'unknown': 3,
}


def addstr(win, *args, **kwargs):
    try:
        win.addstr(*args, **kwargs)
    except curses.error:
        pass


def line(msg, width):
    return msg[:width] + ' ' * (width - len(msg))


def title(win, msg):
    height, width = win.getmaxyx()
    addstr(win, 0, 0, line(msg, width), curses.color_pair(COLORS['bar']))


def status(win, msg):
    height, width = win.getmaxyx()
    addstr(win, height - 1, 0, line(msg, width), curses.color_pair(COLORS['bar']))


def color_for_state(state):
    try:
        return curses.color_pair(COLORS['state_' + STATES[state]])
    except:
        return curses.color_pair(COLORS['default'])


def filter_items(icinga_items, only_broken, filters):
    hosts = icinga_items['hosts']
    services = icinga_items['services']

    hosts_downtime = set()
    buffered = []

    for host in hosts:
        if host.downtime_depth > 0:
            hosts_downtime.add(host.host_name)
        if only_broken:
            if host.host_name in hosts_downtime:
                continue
            if host.state == STATES['ok'] or host.state_type == 0:
                continue

        buffered.append(host)

    for service in services:
        if only_broken:
            if service.downtime_depth > 0:
                continue
            if service.host_name in hosts_downtime:
                continue
            if service.state == STATES['ok'] or service.state_type == 0:
                continue

        buffered.append(service)

    mut_filters = filters[:]
    while mut_filters:
        f = mut_filters.pop(0)
        match_re_comp = re.compile(f, re.I)

        new_buffered = []
        for item in buffered:
            if match_re_comp.search(item.get_line_to_show(0)):
                new_buffered.append(item)
        buffered = new_buffered

    return buffered


def list_items(win, offset, current, icinga_items, selected):
    height, width = win.getmaxyx()
    margin_top = margin_bottom = 1

    try:
        output_lines = icinga_items[current].output_lines
        output_extra = 1
    except IndexError:
        output_lines = []
        output_extra = 0

    used_by_output_pane = len(output_lines) + output_extra
    usable_height_for_items = height - margin_top - margin_bottom - used_by_output_pane
    if usable_height_for_items <= 0:
        return 0

    max_host_len = 0
    for i in icinga_items:
        max_host_len = max(max_host_len, len(i.host_name))

    at_y = margin_top
    for i, item in enumerate(icinga_items[offset:]):
        if at_y >= margin_top + usable_height_for_items:
            break

        attrs = color_for_state(item.state)
        if i + offset == current:
            attrs |= curses.A_REVERSE

        if item in selected:
            attrs |= curses.A_BOLD

        addstr(win, at_y, 0, line(item.get_line_to_show(max_host_len), width), attrs)

        at_y += 1

    if len(output_lines) > 0:
        at_y = margin_top + usable_height_for_items
        addstr(win, at_y, 0, line('', width), curses.color_pair(COLORS['bar']))
        at_y += 1
        for output in output_lines:
            addstr(win, at_y, 0, line(output, width), curses.color_pair(COLORS['default']))
            at_y += 1

    return used_by_output_pane


def query_new_filter(win, existing):
    new = query_string(win, 'Add filter: ')
    if not new:
        return existing

    try:
        re.compile(new, re.I)
    except:
        status(win, 'Invalid regular expression!')
        win.refresh()
        sleep(2)
        return existing

    return existing + [new]


def query_string(win, prompt):
    height, width = win.getmaxyx()
    addstr(win, height - 1, 0, prompt, curses.color_pair(COLORS['bar']))
    curses.curs_set(True)
    win.refresh()

    editwin = curses.newwin(1, width - len(prompt), height - 1, len(prompt))
    box = Textbox(editwin)
    box.edit()
    out = box.gather()

    curses.curs_set(False)
    del editwin
    win.touchwin()
    win.refresh()

    return out.strip()


def run_external_tool(items, external_tool):
    if not external_tool:
        return

    args = split(external_tool)

    signal(SIGCHLD, SIG_IGN)
    for i in items:
        args_now = []
        for a in args:
            if a == '__HOST__':
                args_now.append(i.host_name)
            elif a == '__SERVICE__':
                args_now.append(i.service_name)
            elif a == '__OUTPUT__':
                args_now.append('\n'.join(i.output_lines))
            else:
                args_now.append(a)

        Popen(args_now)


def show_help_screen(win):
    msg = '''
    q        Quit program
    ?        Help

    r        Refresh

    b        Toggle "show only broken items"
    d        Put current / selected items in downtime
    D        Put current / selected host and all its services in downtime
    n        Check current / selected items NOW
    e        Launch external tool on current item

    f        Add filter regex
    F        Pop right-most filter
    H        Add host name of currently selected item to filters
    S        Add service name of currently selected item to filters

    <Space>  Select / unselect current item
    a        Select all currently visible items
    s        Toggle "show only selected items"
    c        Clear selection

    j, k     Scroll one line down / up
    g, G     Scroll to top / bottom
    ^F, ^G   Scroll half a page down / up
    '''

    height, width = win.getmaxyx()
    at_y = margin_top = margin_bottom = 1
    for m in msg.strip().splitlines():
        if at_y >= height - margin_bottom:
            break

        m = m.strip()
        addstr(win, at_y, 0, '  ' + m, curses.color_pair(COLORS['default']))
        at_y += 1


def standard_status(win, filters, only_broken, only_selected, refresh_delta, refresh_every):
    height, width = win.getmaxyx()

    flt = f'Filter: {" > ".join(filters) if filters else "<none>"}'

    indicators = f'[{"b" if only_broken else "-"}{"s" if only_selected else "-"}]'
    fraction = refresh_delta.total_seconds() / refresh_every.total_seconds()
    fraction = max(0, min(1, fraction))
    fill_len = 10
    fill = int(fill_len * fraction)
    fill_pad = fill_len - fill
    indicators = '[' + '#' * fill + '-' * fill_pad + ']' + indicators

    msg = flt
    msg += ' ' * max(0, width - len(flt) - len(indicators))
    msg += indicators

    return msg


def interact(win, icinga, external_tool):
    curses.curs_set(False)

    curses.use_default_colors()
    curses.init_pair(COLORS['bar'], curses.COLOR_YELLOW, curses.COLOR_BLUE)
    curses.init_pair(COLORS['state_ok'], curses.COLOR_GREEN, -1)
    curses.init_pair(COLORS['state_warning'], curses.COLOR_YELLOW, -1)
    curses.init_pair(COLORS['state_critical'], curses.COLOR_RED, -1)
    curses.init_pair(COLORS['state_unknown'], curses.COLOR_MAGENTA, -1)

    filters = []

    filter_dirty = True
    force_refresh = False
    icinga_items = None
    only_broken = True
    scroll_dirty = True
    selected = set()
    only_selected = False
    show_help = False

    refresh_every = timedelta(seconds=30)
    refresh_delta = timedelta(seconds=0)

    current = 0
    offset = 0

    title(win, HELP)
    status(win, '')

    while True:
        height, width = win.getmaxyx()

        if icinga_items is None or force_refresh:
            status(win, 'Refreshing ...')
            win.refresh()

            selected = set()
            icinga_items = icinga.get_current_state()
            last_key = datetime.now()
            refresh_delta = timedelta(seconds=0)
            filter_dirty = True
            scroll_dirty = True
            force_refresh = False

        if filter_dirty:
            if only_selected:
                to_display = sorted(selected)
            else:
                to_display = sorted(filter_items(icinga_items, only_broken, filters))
            scroll_dirty = True
            filter_dirty = False

        if scroll_dirty:
            current = 0
            offset = 0
            scroll_dirty = False

        win.erase()
        title(win, HELP)

        if show_help:
            show_help_screen(win)
            status(win, '')
        else:
            status(win, standard_status(
                win, filters, only_broken, only_selected,
                refresh_delta, refresh_every,
            ))
            border_pane = list_items(win, offset, current, to_display, selected)
            height -= border_pane

        win.refresh()
        win.timeout(1000)
        try:
            char = win.getkey()
        except:
            char = None
        win.timeout(-1)

        if selected:
            items_for_action = selected
        else:
            try:
                items_for_action = set([to_display[current]])
            except IndexError:
                items_for_action = set()

        if char in ['q']:
            return
        if char in ['?']:
            show_help = not show_help
        if char in ['b']:
            only_broken = not only_broken
            filter_dirty = True
        if char in ['d', 'D']:
            duration = query_string(win, 'Duration (30s, 5m, 1h, 2d): ')
            comment = query_string(win, 'Comment: ')
            status(win, 'Setting downtime ...')
            win.refresh()
            if char == 'd':
                icinga.set_downtime(items_for_action, comment, duration)
            else:
                icinga.set_downtime_for_host(items_for_action, comment, duration)
            force_refresh = True
        if char in ['n']:
            status(win, 'Queueing checks ...')
            win.refresh()
            icinga.queue_check(items_for_action)
            force_refresh = True
        if char in ['e']:
            run_external_tool(items_for_action, external_tool)
        if char in ['r']:
            force_refresh = True
        if char in ['f']:
            filters = query_new_filter(win, filters)
            filter_dirty = True
        if char in ['F']:
            if filters:
                filters.pop()
                filter_dirty = True
        if char in ['H', 'S']:
            try:
                ci = to_display[current]
            except IndexError:
                pass
            else:
                filters.append(ci.host_name if char == 'H' else ci.service_name)
                filter_dirty = True

        # Selections.
        if char in [' ']:
            try:
                selected.remove(to_display[current])
            except KeyError:
                selected.add(to_display[current])
            current += 1

        if char in ['a']:
            selected = to_display
        if char in ['c']:
            selected = set()
        if char in ['s']:
            only_selected = not only_selected
            filter_dirty = True

        # Scrolling.
        bottompad = starty = 1

        if char in ['j', 'KEY_DOWN']: current += 1
        if char in ['k', 'KEY_UP']: current -= 1

        if char in ['g', 'KEY_HOME']: current = 0
        if char in ['G', 'KEY_END']: current = len(to_display) - 1

        if char in [chr(6), '^F', 'KEY_NPAGE']: current += int(0.5 * (height - starty))
        if char in [chr(2), '^B', 'KEY_PPAGE']: current -= int(0.5 * (height - starty))

        if current < 0:
            current = 0
        if current >= len(to_display):
            current = len(to_display) - 1

        # Scroll up or down if needed.
        if current - offset >= (height - bottompad) - starty:
            offset = current - (height - bottompad) + starty + 1
        if current - offset <= -1:
            offset = current

        if offset < 0:
            offset = 0
        if offset >= len(to_display):
            offset = len(to_display) - 1

        if char is not None:
            last_key = datetime.now()
            refresh_delta = timedelta(seconds=0)
        else:
            refresh_delta = datetime.now() - last_key
            if refresh_delta > refresh_every:
                force_refresh = True
                last_key = datetime.now()


if __name__ == '__main__':
    with open(expanduser('~/.terminga'), 'r') as fp:
        lines = fp.read().splitlines()

    icinga = Icinga()
    icinga.settings = {
        'auth': (lines[1], lines[2]),
        'base_url': lines[0],
    }

    if len(lines) >= 4:
        external_tool = lines[3]
    else:
        external_tool = None

    curses.wrapper(interact, icinga, external_tool)
